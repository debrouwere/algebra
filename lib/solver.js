// Generated by CoffeeScript 1.10.0
(function() {
  var OPERATORS, _, binomials, calculate, destructured, expand, factor, isExpression, isNumber, modifies, ref, ref1, simplify, substitute, use;

  _ = require('underscore');

  ref = require('./parser'), OPERATORS = ref.OPERATORS, destructured = ref.destructured, substitute = ref.substitute, calculate = ref.calculate;

  ref1 = require('./parser'), isNumber = ref1.isNumber, isExpression = ref1.isExpression;

  modifies = require('./utils').modifies;

  use = function(strategies) {
    var applyStrategies;
    return applyStrategies = modifies(isExpression, function(expr) {
      var i, len, pattern, ref2, replacement, state;
      expr = _.map(expr, applyStrategies);
      for (i = 0, len = strategies.length; i < len; i++) {
        ref2 = strategies[i], pattern = ref2[0], replacement = ref2[1];
        state = {};
        if (match(expr, pattern, state)) {
          expr = substitute(replacement, state);
        }
      }
      return expr;
    });
  };

  binomials = {
    '(a + b)(a - b)': 'a^2 - b^2',
    '(x + y)^2': 'x^2 + 2 * a * b + b^2',
    '(a - b)^2': 'a^2 - 2 * a * b + b^2'
  };


  /*
  NOTE: we can already simplify expressions that match a pattern
  but also include some cruft at either end, but we can't yet convert
  a^2 + 2*a*b + c + b^2 to (a+b)^2 + c -- unfortunately canonicalization
  is not sufficient to catch this, so in addition to canonicalization we'll
  have to match all possible permutations of complex expressions
  (but only permutations of expressions that consist of expressions, 
  every individual expression can be kept in canonical form)
   */

  expand = use(binomials);

  factor = use(_.invert(binomials));

  simplify = _.compose(calculate, factor, calculate);

  module.exports = {
    expand: expand,
    factor: factor,
    calculate: calculate,
    simplify: simplify
  };

}).call(this);
