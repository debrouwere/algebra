// Generated by CoffeeScript 1.10.0
(function() {
  var OPERATORS, PRECEDENCE, SIGILS, VARIABLES, _, apply, calculate, canonical, cast, commute, compare, depth, destructured, diff, flip, hasPrecedence, i, isCommutative, isExpression, isNumber, isOperator, isScalar, isSimple, isSimpleExpression, isString, isVariable, leftmost, match, modifies, needs, nest, order, parse, patterns, rank, ref, rightmost, shunt, simplify, substitute, sum, test, tokenize, tuples, unwrap, variables,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  _ = require('underscore');

  ref = require('./utils'), modifies = ref.modifies, needs = ref.needs, apply = ref.apply, sum = ref.sum;

  OPERATORS = {
    '^': function(a, b) {
      return Math.pow(a, b);
    },
    '*': function(a, b) {
      return a * b;
    },
    '/': function(a, b) {
      return a / b;
    },
    '+': function(a, b) {
      return a + b;
    },
    '-': function(a, b) {
      return a - b;
    }
  };

  PRECEDENCE = {
    '^': 4,
    '*': 3,
    '/': 3,
    '+': 2,
    '-': 2
  };

  SIGILS = _.keys(OPERATORS);

  VARIABLES = (function() {
    var k, len, ref1, results;
    ref1 = _.range(97, 123);
    results = [];
    for (k = 0, len = ref1.length; k < len; k++) {
      i = ref1[k];
      results.push(String.fromCharCode(i));
    }
    return results;
  })();

  rank = function(expr) {
    return [Function, Array, String, Number].indexOf(expr.constructor);
  };

  compare = function(a, b) {
    return (a > b) - (b - a);
  };

  hasPrecedence = function(a, b) {
    var ranking;
    if (ranking = compare(rank(a), rank(b))) {
      return ranking;
    } else if (indexOf.call(SIGILS, a) >= 0 && indexOf.call(SIGILS, b) >= 0) {
      return PRECEDENCE[a] - PRECEDENCE[b];
    } else {
      throw new Error("Cannot determine precedence of " + a.constructor.name + " and " + b.constructor.name + ": " + a + ", " + b);
    }
  };

  cast = function(string) {
    var number;
    number = parseFloat(string);
    if (isNaN(number)) {
      return string;
    } else {
      return number;
    }
  };

  tokenize = function(s) {
    var cleaned, curr, k, len, pattern, prev, rawTokens, ref1, tokens;
    pattern = /(\w+|-?[\d\.]+|[\(\)\*\/+-\^])/g;
    rawTokens = s.match(pattern);
    tokens = _.map(rawTokens, cast);
    cleaned = [];
    ref1 = _.range(tokens.length);
    for (k = 0, len = ref1.length; k < len; k++) {
      i = ref1[k];
      prev = tokens[i - 1];
      curr = tokens[i];
      if ((!prev || indexOf.call(SIGILS, prev) >= 0 || prev === '(') && indexOf.call('+-', curr) >= 0) {
        cleaned.push(parseFloat(curr + "1"), '*');
      } else {
        cleaned.push(curr);
      }
    }
    return cleaned;
  };

  shunt = function(tokens) {
    var k, len, ops, output, ref1, token;
    output = [];
    ops = [];
    for (k = 0, len = tokens.length; k < len; k++) {
      token = tokens[k];
      switch (false) {
        case token !== '(':
          ops.push(token);
          break;
        case token !== ')':
          while ((_.last(ops)) !== '(') {
            output.push(ops.pop());
          }
          ops.pop();
          break;
        case indexOf.call(SIGILS, token) < 0:
          while (ops.length && (ref1 = _.last(ops), indexOf.call(SIGILS, ref1) >= 0) && (hasPrecedence(_.last(ops), token)) > -1) {
            output.push(ops.pop());
          }
          ops.push(token);
          break;
        default:
          output.push(token);
      }
    }

    /*
    Perhaps, while parsing, keep track of whether the current expression is valid, 
    and output the last valid parsed expression as well as the part that was not
    successfully parsed. That way, we can provide more intelligent error messages.
    (Though in reality, I think most errors will be unclosed braces and trailing
    operators while the user is still typing)
    
    if ops.length
        last = ops.pop()
        if last in '()'
            throw new Error 'mismatched parentheses'
        else
            output.push last
     */
    while (ops.length) {
      output.push(ops.pop());
    }
    return output;
  };

  nest = function(tokens) {
    var k, len, stack, token;
    stack = [];
    for (k = 0, len = tokens.length; k < len; k++) {
      token = tokens[k];
      if (indexOf.call(SIGILS, token) >= 0) {
        stack.push([stack.pop(), stack.pop(), token].reverse());
      } else {
        stack.push(token);
      }
    }
    return stack.pop();
  };

  parse = function(s) {
    var tokens;
    tokens = tokenize(s);
    return nest(shunt(tokens));
  };

  patterns = function(mapping) {
    var keys, values;
    keys = _.map(_.keys(mapping), parse);
    values = _.map(_.values(mapping), parse);
    return _.zip(keys, values);
  };

  unwrap = function(obj) {
    if (obj.length != null) {
      return obj[0];
    } else {
      return obj;
    }
  };

  destructured = function(fn) {
    return function() {
      var expr, l, op, options, r;
      expr = arguments[0], options = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      op = expr[0], l = expr[1], r = expr[2];
      return fn.apply(null, [expr, op, l, r].concat(slice.call(options)));
    };
  };

  leftmost = modifies(isExpression, destructured(function(expr, op, l, r) {
    if (isSimpleExpression(expr)) {
      return l;
    } else {
      return leftmost(l);
    }
  }));

  rightmost = modifies(isExpression, destructured(function(expr, op, l, r) {
    if (isSimpleExpression(expr)) {
      return r;
    } else {
      return rightmost(r);
    }
  }));

  isOperator = function(expr) {
    return indexOf.call(SIGILS, expr) >= 0;
  };

  isString = function(expr) {
    var isOp, isStr;
    isOp = isOperator(expr);
    isStr = expr instanceof String || (typeof expr) === 'string';
    return isStr && !isOp;
  };

  isVariable = isString;

  isScalar = function(expr) {
    return !(expr instanceof Array);
  };

  isNumber = function(expr) {
    return expr instanceof Number || (typeof expr) === 'number';
  };

  isExpression = function(expr) {
    return !isScalar(expr);
  };

  isSimpleExpression = function(expr) {
    return (isExpression(expr)) && _.every(expr, isScalar);
  };

  isSimple = function(expr) {
    return (isScalar(expr)) || (isSimpleExpression(expr));
  };

  isCommutative = destructured(function(expr, op, l, r) {
    if (isExpression(expr)) {
      return indexOf.call('*+', op) >= 0;
    } else {
      return false;
    }
  });

  depth = function(expr) {
    if (isScalar(expr)) {
      return 0;
    } else {
      return 1 + _.max(_.map(expr, depth));
    }
  };

  tuples = function(expr) {
    if (isScalar(expr)) {
      return 0;
    } else if (isSimpleExpression(expr)) {
      return 1;
    } else {
      return 1 + sum(_.map(expr, tuples));
    }
  };

  order = destructured(function(expr, op, l, r) {
    if (isExpression) {
      if (op === '^' && (isVariable(l)) || (isVariable(r))) {
        return r;
      }
    } else {
      return 0;
    }
  });

  variables = function(expr) {
    if (isString(expr)) {
      return [expr];
    } else if (isExpression(expr)) {
      return _.uniq(_.flatten(_.map(expr.slice(1), variables)));
    } else {
      return [];
    }
  };

  flip = function(l, i, j) {
    var ref1;
    l = l.slice();
    ref1 = [l[j], l[i]], l[i] = ref1[0], l[j] = ref1[1];
    return l;
  };

  commute = modifies(isExpression, function(expr) {
    if (isCommutative(expr)) {
      return flip(expr, 1, 2);
    } else {
      return expr;
    }
  });

  canonical = modifies(isExpression, destructured(function(expr, op, l, r) {
    if ((isCommutative(expr)) && (compare(l, r)) < 0) {
      return commute(expr);
    } else {
      return expr;
    }
  }));

  substitute = modifies(isExpression, function(expr, state, recursive) {
    var el, k, len, results;
    if (recursive == null) {
      recursive = true;
    }
    if (recursive) {
      expr = _.map(expr, _.partial(substitute, _, state));
    }
    results = [];
    for (k = 0, len = expr.length; k < len; k++) {
      el = expr[k];
      results.push(state[el] || el);
    }
    return results;
  });


  /*
  NOTE: we can already simplify expressions that match a pattern
  but also include some cruft at either end, but we can't yet convert
  a^2 + 2*a*b + c + b^2 to (a+b)^2 + c -- unfortunately canonicalization
  is not sufficient to catch this, so in addition to canonicalization we'll
  have to match all possible permutations of complex expressions
  (but only permutations of expressions that consist of expressions, 
  every individual expression can be kept in canonical form)
   */

  simplify = modifies(isExpression, function(expr) {
    var k, len, pattern, ref1, replacement, state;
    expr = _.map(expr, simplify);
    for (k = 0, len = strategies.length; k < len; k++) {
      ref1 = strategies[k], replacement = ref1[0], pattern = ref1[1];
      state = {};
      if (match(expr, pattern, state)) {
        expr = substitute(replacement, state);
      }
    }
    return expr;
  });


  /*
  NOTE: while `calculate` can do partial calculations that keep
  symbols intact, it's not quite smart enough to use the 
  associative property to rejig the expression tree, so it 
  currently cannot simplify e.g. `3 + a + 5` to `8 + a`
   */

  calculate = modifies(isExpression, destructured(function(expr, op, l, r) {
    l = calculate(l);
    r = calculate(r);
    if ((isNumber(l)) && (isNumber(r))) {
      return OPERATORS[op](l, r);
    } else {
      return [op, l, r];
    }
  }));

  test = function(a, b) {
    var ax, bx, k, len, map, ref1, values, vars, x;
    vars = _.uniq((variables(a)).concat(variables(b)));
    ref1 = [-100, 100];
    for (k = 0, len = ref1.length; k < len; k++) {
      x = ref1[k];
      values = (function() {
        var len1, m, ref2, results;
        ref2 = _.range(vars.length);
        results = [];
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          i = ref2[m];
          results.push(x);
        }
        return results;
      })();
      map = _.object(vars, values);
      ax = substitute(a, map);
      bx = substitute(b, map);
      if ((calculate(ax)) !== (calculate(bx))) {
        return false;
      }
    }
    return true;
  };

  match = function(expr, pattern, state) {
    var isAbstract, isComparable;
    if (state == null) {
      state = {};
    }
    expr = canonical(substitute(expr, state, false));
    pattern = canonical(substitute(pattern, state, false));
    isComparable = expr && expr.constructor === pattern.constructor;
    isAbstract = (isString(expr)) || (isString(pattern));
    if (!(isComparable || isAbstract)) {
      return false;
    }
    if (isExpression(pattern)) {
      return _.every(_.map(_.zip(expr, pattern, _.times(3, function() {
        return state;
      })), apply(match)));
    } else if (pattern === expr) {
      return true;
    } else if (isString(pattern)) {
      state[pattern] = expr;
      return true;
    } else {
      return false;
    }
  };


  /*
  NOTE: this is part of the groundwork for later being able to spot mistakes (e.g. misuse 
  of the distributive property): "you changed _ into _; it looks like you applied _
  but you can only do that with _ or _, not with _"
   */

  diff = function(left, right, context) {
    var l, r;
    if ((isSimple(left)) || (isSimple(right))) {
      if (match(left, right)) {
        return [];
      } else {
        return [
          {
            left: left,
            right: right,
            context: context
          }
        ];
      }
    } else {
      return _.flatten((function() {
        var k, len, ref1, ref2, results;
        ref1 = _.zip(left, right);
        results = [];
        for (k = 0, len = ref1.length; k < len; k++) {
          ref2 = ref1[k], l = ref2[0], r = ref2[1];
          results.push(diff(l, r, left));
        }
        return results;
      })(), true);
    }
  };

  module.exports = {
    OPERATORS: OPERATORS,
    PRECEDENCE: PRECEDENCE,
    SIGILS: SIGILS,
    VARIABLES: VARIABLES,
    hasPrecedence: hasPrecedence,
    tokenize: tokenize,
    shunt: shunt,
    nest: nest,
    parse: parse,
    patterns: patterns,
    leftmost: leftmost,
    rightmost: rightmost,
    destructured: destructured,
    commute: commute,
    canonical: canonical,
    substitute: substitute,
    isOperator: isOperator,
    isString: isString,
    isVariable: isVariable,
    isScalar: isScalar,
    isNumber: isNumber,
    isExpression: isExpression,
    isSimpleExpression: isSimpleExpression,
    isSimple: isSimple,
    isCommutative: isCommutative,
    depth: depth,
    tuples: tuples,
    order: order,
    test: test,
    match: match,
    diff: diff,
    simplify: simplify,
    calculate: calculate
  };

}).call(this);
