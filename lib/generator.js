// Generated by CoffeeScript 1.10.0
(function() {
  var CONSTANT, Context, FIRST_ORDER, SECOND_ORDER, SIGILS, VARIABLES, _, choose, commute, confuse, confusors, conjure, expansion, factor, isCommutative, isExpression, isNumber, isScalar, match, parse, pattern, ref, ref1, ref2, shuffle, strategies;

  _ = require('underscore');

  ref = require('./parser'), isCommutative = ref.isCommutative, isExpression = ref.isExpression, isNumber = ref.isNumber, isScalar = ref.isScalar;

  ref1 = require('./parser'), parse = ref1.parse, match = ref1.match, commute = ref1.commute;

  ref2 = require('./parser'), VARIABLES = ref2.VARIABLES, SIGILS = ref2.SIGILS;

  CONSTANT = {
    unknowns: 1,
    order: [0, 0],
    terms: 1,
    magnitude: 3
  };

  FIRST_ORDER = {
    unknowns: 1,
    order: [0, 1],
    terms: 3,
    magnitude: 1
  };

  SECOND_ORDER = {
    unknowns: 1,
    order: [0, 2],
    terms: 3,
    magnitude: 1
  };

  conjure = function(options) {
    var C, c, hi, i, j, len, len1, lo, n, op, ref3, ref4, ref5, term, terms, u, unknowns, x;
    if (options == null) {
      options = {};
    }
    options = _.defaults(options, SECOND_ORDER);
    C = Math.pow(10, options.magnitude);
    unknowns = _.shuffle(VARIABLES);
    terms = [];
    ref3 = options.order, lo = ref3[0], hi = ref3[1];
    ref4 = _.range(options.unknowns);
    for (i = 0, len = ref4.length; i < len; i++) {
      u = ref4[i];
      x = unknowns.pop();
      ref5 = _.range(lo, hi + 1);
      for (j = 0, len1 = ref5.length; j < len1; j++) {
        n = ref5[j];
        op = _.sample(['+', '-']);
        c = _.random(1, C);
        if (n === 0) {
          term = c;
        } else if (n === 1) {
          term = ['*', c, x];
        } else {
          term = ['*', c, ['^', x, n]];
        }
        if (terms.length) {
          terms = [[op, term, terms[0]]];
        } else {
          terms.push(term);
        }
      }
    }
    return terms[0];
  };

  shuffle = function(expr) {};

  strategies = {
    '0': '0 * v',
    '(a+b)^2': 'a^2 + 2*a*b + b^2'
  };

  strategies = (function() {
    var results;
    results = [];
    for (pattern in strategies) {
      expansion = strategies[pattern];
      results.push([parse(pattern), parse(expansion)]);
    }
    return results;
  })();

  confusors = {
    'square': function(expr) {
      return ['^', ['^', expr, 2], 0.5];
    },
    'cancel': function(expr) {
      var a;
      a = _.random(100);
      return ['-', ['+', expr, a], a];
    },
    'null': function(expr) {
      var a;
      a = _.random(100);
      return ['+', expr, ['*', a, 0]];
    },
    'multiply': function(expr) {
      var a;
      a = _.random(100);
      return ['/', ['*', expr, a], a];
    },
    'power': function(expr) {
      return ['^', expr, 1];
    }
  };

  choose = function(l) {
    var ix;
    ix = _.random(0, l.length - 1);
    return l[ix];
  };

  Context = (function() {
    function Context() {
      this.freeSymbols = ['x', 'y', 'z'];
    }

    Context.prototype.symbol = function() {
      return choose(['x', 'y', 'z']);
    };

    Context.prototype.scalar = function(max) {
      if (max == null) {
        max = 10;
      }
      return (choose([this.symbol, this.integer]))();
    };

    Context.prototype.integer = function(max) {
      if (max == null) {
        max = 10;
      }
      return _.random(-max, max);
    };

    return Context;

  })();

  factor = function(expr) {
    var i, len, ref3, replacement, state;
    for (i = 0, len = strategies.length; i < len; i++) {
      ref3 = strategies[i], pattern = ref3[0], replacement = ref3[1];
      state = {};
      if (match(expr, pattern, state)) {
        expr = substitute(replacement, state);
      }
    }
    return expr;
  };


  /*
  
  The confusor mechanism is getting better, but there is still much work to do
  
  - prefer depth, in particular the confusor sometimes retains (expr + a - a) as is, 
    which is what you'd expect when you randomize everything and have a fixed amount
    of iterations, but really, it leads to exercises that don't alwayslook great
  - alternatively or additionally, partially solve some of the sums to hide the 
    symmetry that's at the root of every confusor
  - figure out how to add in expansions (2 variable polynomials), perhaps by
    updating the conjuring mechanism, or perhaps by allowing c=a+b type replacements
  - incorporate negative numbers (which is where it usually gets hairy for students,
    who must keep track of the order of operations)
  - it has to be possible to really craft a particular kind of exercises that trains
    one particular rule -- this will be a combination of specifying a subset of 
    confusors, a subset of strategies, and then most importantly making sure
    the conjuring and confusion mechanisms work together so that these strategies
    (e.g. factorization) can actually be employed -- as well as a more advanced
    pattern matcher, which reorders patterns into every possible permutation or 
    into a canonical form, so it can detect e.g. the binomial pattern in
    `a^2 + b^2 + c + d + 2ab`
  
  Also see the notes about conjuring in the design directory. As mentioned there, there's
  no harm in manually creating exercises for now and give the other parts of the 
  application some love, like the mistake differ/detector/explainer part.
   */

  confuse = function(expr, n) {
    var confusor, l, nl, nr, nx, op, r;
    if (n === 0) {
      return expr;
    } else if (n === 1) {
      confusor = _.sample(_.values(confusors));
      return confusor(expr);
    } else if (isScalar(expr)) {
      confusor = _.sample(_.values(confusors));
      return confuse(confusor(expr), n - 1);
    } else {
      op = expr[0], l = expr[1], r = expr[2];
      nx = _.random(n);
      nl = _.random(n - nx);
      nr = n - nx - nl;
      return confuse([op, confuse(l, nl), confuse(r, nr)], nx);
    }
  };

  module.exports = {
    CONSTANT: CONSTANT,
    FIRST_ORDER: FIRST_ORDER,
    SECOND_ORDER: SECOND_ORDER,
    conjure: conjure,
    confuse: confuse
  };

}).call(this);
