// Generated by CoffeeScript 1.10.0
(function() {
  var _, braces, destructured, hasPrecedence, indent, isExpression, isNumber, isScalar, isString, leftmost, modifies, needs, needsParens, parens, ref, ref1, ref2, rightmost, text, toLaTeX, toString, toTree,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  ref = require('./utils'), modifies = ref.modifies, needs = ref.needs;

  ref1 = require('./parser'), isExpression = ref1.isExpression, isNumber = ref1.isNumber, isString = ref1.isString, isScalar = ref1.isScalar, hasPrecedence = ref1.hasPrecedence;

  ref2 = require('./parser'), destructured = ref2.destructured, leftmost = ref2.leftmost, rightmost = ref2.rightmost;

  parens = function(s) {
    return "(" + s + ")";
  };

  braces = function(s) {
    return "{" + s + "}";
  };

  needsParens = function(a, b) {
    if ((isExpression(a)) && (isExpression(b))) {
      return (hasPrecedence(a[0], b[0])) > 0;
    } else {
      return false;
    }
  };

  toString = modifies(isExpression, destructured(function(expr, op, l, r) {
    var ls, ops, ref3, rs;
    ref3 = _.map(expr, toString), ops = ref3[0], ls = ref3[1], rs = ref3[2];
    if (indexOf.call('^', op) < 0) {
      ops = " " + ops + " ";
    }
    if (needsParens(expr, l)) {
      ls = parens(ls);
    }
    if (needsParens(expr, r)) {
      rs = parens(rs);
    }
    return "" + ls + ops + rs;
  }));

  indent = function(s, n) {
    var i, indentation;
    indentation = ((function() {
      var j, len, ref3, results;
      ref3 = _.range(n);
      results = [];
      for (j = 0, len = ref3.length; j < len; j++) {
        i = ref3[j];
        results.push(' ');
      }
      return results;
    })()).join('');
    return indentation + (s.replace(/\n/g, '\n' + indentation));
  };

  toTree = function(expr, indentation) {
    var l, op, r;
    if (indentation == null) {
      indentation = 0;
    }
    if (isScalar(expr)) {
      return indent(expr.toString(), indentation);
    } else {
      op = toTree(expr[0], indentation);
      l = toTree(expr[1], indentation + 2);
      r = toTree(expr[2], indentation + 2);
      return op + "\n" + l + "\n" + r;
    }
  };

  text = function(s) {
    return "\\text{" + s + "}";
  };

  toLaTeX = modifies(isExpression, destructured(function(expr, op, l, r, fractions) {
    var isFraction, ls, ops, ref3, rs, writer;
    if (fractions == null) {
      fractions = true;
    }
    isFraction = fractions && op === '/';
    writer = _.partial(toLaTeX, _, !isFraction);
    ref3 = _.map(expr, writer), ops = ref3[0], ls = ref3[1], rs = ref3[2];
    if ((isString(l)) && l.length > 1) {
      ls = text(ls);
    }
    if ((isString(r)) && r.length > 1) {
      rs = text(rs);
    }
    if (indexOf.call('^', op) < 0) {
      ops = " " + ops + " ";
    }
    if (op === '*') {
      if ((isNumber(rightmost(l))) && (isNumber(leftmost(r)))) {
        ops = " \\cdot ";
      } else if (l === -1 && (isString(leftmost(r)))) {
        ls = '-';
        ops = '';
      } else {
        ops = ' ';
      }
    }
    if (!isFraction && needsParens(expr, l)) {
      ls = parens(ls);
    }
    if (op === '^') {
      rs = braces(rs);
    } else if (!isFraction && needsParens(expr, r)) {
      rs = parens(rs);
    }
    if (fractions && op === '/') {
      return "\\frac{\n  " + ls + "\n}{\n  " + rs + "\n}";
    } else {
      return "" + ls + ops + rs;
    }
  }));

  module.exports = {
    toString: toString,
    toTree: toTree,
    toLaTeX: toLaTeX
  };

}).call(this);
